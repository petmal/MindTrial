// Copyright (C) 2025 Petr Malik
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at <https://mozilla.org/MPL/2.0/>.

package formatters

import (
	"cmp"
	"fmt"
	"math"
	"strings"
	"time"

	"github.com/petmal/mindtrial/pkg/utils"
	"github.com/petmal/mindtrial/runners"

	"github.com/sergi/go-diff/diffmatchpatch"
)

const (
	// Unknown represents an unknown status.
	Unknown = "Unknown"
	// Passed indicates that the task finished successfully with a correct result.
	Passed = "Passed"
	// Failed indicates that the task finished successfully but with an incorrect result.
	Failed = "Failed"
	// Error indicates that the task failed to produce a result.
	Error = "Error"
	// Skipped indicates that the task was skipped by the provider.
	Skipped = "Skipped"

	// htmlDiffContentPrefix is an HTML comment prefix added to HTML diff content
	// to disable html-validate inline style warnings for generated diff markup.
	htmlDiffContentPrefix = "<!-- [html-validate-disable-block no-inline-style: generated by go-diff] -->"
)

var timestamp = func(t time.Time) string {
	return t.Format(time.RFC1123Z)
}

// ToStatus converts a runners.ResultKind value to its corresponding human-readable status string.
// Returns "Unknown" for unrecognized result kinds.
func ToStatus(kind runners.ResultKind) string {
	switch kind {
	case runners.Success:
		return Passed
	case runners.Failure:
		return Failed
	case runners.Error:
		return Error
	case runners.NotSupported:
		return Skipped
	}
	return fmt.Sprintf("%s (%d)", Unknown, kind)
}

// CountByKind returns the number of run results of a given kind.
func CountByKind(resultsByKind map[runners.ResultKind][]runners.RunResult, kind runners.ResultKind) int {
	return len(resultsByKind[kind])
}

// TotalDuration computes the total duration of the runs of given kinds.
func TotalDuration(resultsByKind map[runners.ResultKind][]runners.RunResult, include ...runners.ResultKind) (total time.Duration) {
	for _, kind := range include {
		for _, result := range resultsByKind[kind] {
			total += result.Duration
		}
	}
	return
}

// PassRate returns the fraction of tasks that passed out of all attempted tasks
// (passed, failed, error). Skipped tasks are excluded.
func PassRate(resultsByKind map[runners.ResultKind][]runners.RunResult) float64 {
	return rate(
		resultsByKind,
		[]runners.ResultKind{runners.Success},
		[]runners.ResultKind{runners.Success, runners.Failure, runners.Error},
	)
}

// AccuracyRate returns the fraction of correct results (passed) among completed tasks
// (passed or failed). Errors and skipped tasks are excluded.
func AccuracyRate(resultsByKind map[runners.ResultKind][]runners.RunResult) float64 {
	return rate(
		resultsByKind,
		[]runners.ResultKind{runners.Success},
		[]runners.ResultKind{runners.Success, runners.Failure},
	)
}

// ErrorRate returns the fraction of tasks that errored among attempted tasks
// (passed, failed, error). Skipped tasks are excluded.
func ErrorRate(resultsByKind map[runners.ResultKind][]runners.RunResult) float64 {
	return rate(
		resultsByKind,
		[]runners.ResultKind{runners.Error},
		[]runners.ResultKind{runners.Success, runners.Failure, runners.Error},
	)
}

func rate(resultsByKind map[runners.ResultKind][]runners.RunResult, numeratorKinds []runners.ResultKind, denominatorKinds []runners.ResultKind) float64 {
	numerator := 0
	for _, kind := range numeratorKinds {
		numerator += CountByKind(resultsByKind, kind)
	}
	denominator := 0
	for _, kind := range denominatorKinds {
		denominator += CountByKind(resultsByKind, kind)
	}
	if denominator == 0 {
		return 0
	}
	return float64(numerator) / float64(denominator)
}

// Percent converts a fraction (0..1) to a percentage (0..100) rounded to 2 decimals.
func Percent(rate float64) float64 {
	percent := rate * 100
	return math.Round(percent*100) / 100
}

// FormatAnswer formats the result of a runner based on its kind and the specified output format.
// For failures, it generates a diff between expected and actual outputs.
// The useHTML parameter controls whether diffs are formatted as HTML or plain text.
func FormatAnswer(result runners.RunResult, useHTML bool) (answers []string) {
	gotStr := utils.ToString(result.Got)

	switch result.Kind {
	case runners.Success, runners.Error, runners.NotSupported:
		if useHTML {
			gotStr = "<pre>" + gotStr + "</pre>"
		}
		answers = append(answers, gotStr)
	case runners.Failure:
		for _, want := range result.Want.Values() {
			wantStr := utils.ToString(want)
			if useHTML {
				answers = append(answers, htmlDiffContentPrefix+DiffHTML(wantStr, gotStr))
			} else {
				answers = append(answers, DiffText(wantStr, gotStr))
			}
		}
	}
	return
}

// DiffHTML computes an HTML representation of differences between the two given strings.
func DiffHTML(expected string, actual string) string {
	engine, diffs := computeDiff(expected, actual)
	return engine.DiffPrettyHtml(diffs)
}

// DiffText computes a plain-text representation of differences between the two given strings.
func DiffText(expected string, actual string) string {
	if expected != actual {
		engine, diffs := computeDiff(expected, actual)
		return engine.PatchToText(engine.PatchMake(expected, diffs))
	}
	return expected
}

func computeDiff(expected string, actual string) (engine *diffmatchpatch.DiffMatchPatch, diffs []diffmatchpatch.Diff) {
	engine = diffmatchpatch.New()
	diffs = engine.DiffCleanupSemantic(engine.DiffMain(expected, actual, false))
	return
}

// ForEachOrdered iterates over map elements in key order.
// For each key-value pair, it calls fn. If fn returns an error,
// iteration stops and returns that error.
func ForEachOrdered[K cmp.Ordered, V any](m map[K]V, fn func(key K, value V) error) error {
	for _, key := range utils.SortedKeys(m) {
		if err := fn(key, m[key]); err != nil {
			return err
		}
	}
	return nil
}

// RoundToMS rounds a duration to the nearest millisecond.
func RoundToMS(value time.Duration) time.Duration {
	return value.Round(time.Millisecond)
}

// GroupParagraphs splits a slice of lines into paragraphs separated by blank lines.
// Consecutive non-empty lines are grouped; empty/whitespace-only lines act as paragraph breaks.
func GroupParagraphs(lines []string) [][]string {
	paras := [][]string{}
	current := []string{}
	for _, l := range lines {
		if strings.TrimSpace(l) == "" { // paragraph break
			if len(current) > 0 {
				paras = append(paras, current)
				current = []string{}
			}
			continue
		}
		current = append(current, l)
	}
	if len(current) > 0 {
		paras = append(paras, current)
	}
	return paras
}

// UniqueRuns returns a sorted slice of unique run names from the results.
func UniqueRuns(results runners.Results) []string {
	runSet := make(map[string]struct{})
	for _, providerResults := range results {
		for _, result := range providerResults {
			runSet[result.Run] = struct{}{}
		}
	}
	return utils.SortedKeys(runSet)
}

// Timestamp returns the current time in RFC1123Z format.
func Timestamp() string {
	return timestamp(time.Now())
}
