// Copyright (C) 2025 Petr Malik
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at <https://mozilla.org/MPL/2.0/>.

package formatters

import (
	"cmp"
	"fmt"
	"regexp"
	"time"

	"github.com/petmal/mindtrial/runners"

	"slices"

	"github.com/sergi/go-diff/diffmatchpatch"
)

const (
	// Unknown represents an unknown status.
	Unknown = "Unknown"
	// Passed indicates that the task finished successfully with a correct result.
	Passed = "Passed"
	// Failed indicates that the task finished successfully but with an incorrect result.
	Failed = "Failed"
	// Error indicates that the task failed to produce a result.
	Error = "Error"
	// Skipped indicates that the task was skipped by the provider.
	Skipped = "Skipped"

	htmlDiffContentPrefix = "<!-- [html-validate-disable-block no-inline-style: generated by go-diff] -->"
)

var newlineMatcher = regexp.MustCompile(`\r?\n`)
var timestamp = func(t time.Time) string {
	return t.Format(time.RFC1123Z)
}

// ToStatus converts a runners.ResultKind value to its corresponding human-readable status string.
// Returns "Unknown" for unrecognized result kinds.
func ToStatus(kind runners.ResultKind) string {
	switch kind {
	case runners.Success:
		return Passed
	case runners.Failure:
		return Failed
	case runners.Error:
		return Error
	case runners.NotSupported:
		return Skipped
	}
	return fmt.Sprintf("%s (%d)", Unknown, kind)
}

// CountByKind returns the number of run results of a given kind.
func CountByKind(resultsByKind map[runners.ResultKind][]runners.RunResult, kind runners.ResultKind) int {
	return len(resultsByKind[kind])
}

// TotalDuration computes the total duration of the runs of given kinds.
func TotalDuration(resultsByKind map[runners.ResultKind][]runners.RunResult, include ...runners.ResultKind) (total time.Duration) {
	for _, kind := range include {
		for _, result := range resultsByKind[kind] {
			total += result.Duration
		}
	}
	return
}

// FormatAnswer formats the result of a runner based on its kind and the specified output format.
// For failures, it generates a diff between expected and actual outputs.
// The useHTML parameter controls whether diffs are formatted as HTML or plain text.
func FormatAnswer(result runners.RunResult, useHTML bool) (answers []string) {
	switch result.Kind {
	case runners.Success, runners.Error, runners.NotSupported:
		answers = append(answers, result.Got)
	case runners.Failure:
		for _, want := range result.Want.Values() {
			if useHTML {
				answers = append(answers, htmlDiffContentPrefix+DiffHTML(want, result.Got))
			} else {
				answers = append(answers, DiffText(want, result.Got))
			}
		}
	}
	return
}

// DiffHTML computes an HTML representation of differences between the two given strings.
func DiffHTML(expected string, actual string) string {
	engine, diffs := computeDiff(expected, actual)
	return engine.DiffPrettyHtml(diffs)
}

// DiffText computes a plain-text representation of differences between the two given strings.
func DiffText(expected string, actual string) string {
	if expected != actual {
		engine, diffs := computeDiff(expected, actual)
		return engine.PatchToText(engine.PatchMake(expected, diffs))
	}
	return expected
}

func computeDiff(expected string, actual string) (engine *diffmatchpatch.DiffMatchPatch, diffs []diffmatchpatch.Diff) {
	engine = diffmatchpatch.New()
	diffs = engine.DiffCleanupSemantic(engine.DiffMain(expected, actual, false))
	return
}

// ForEachOrdered iterates over map elements in key order.
// For each key-value pair, it calls fn. If fn returns an error,
// iteration stops and returns that error.
func ForEachOrdered[K cmp.Ordered, V any](m map[K]V, fn func(key K, value V) error) error {
	for _, key := range SortedKeys(m) {
		if err := fn(key, m[key]); err != nil {
			return err
		}
	}
	return nil
}

// SortedKeys returns a sorted slice of map keys.
func SortedKeys[K cmp.Ordered, V any](m map[K]V) (keys []K) {
	keys = make([]K, 0, len(m))
	for key := range m {
		keys = append(keys, key)
	}
	slices.Sort(keys)
	return
}

// RoundToMS rounds a duration to the nearest millisecond.
func RoundToMS(value time.Duration) time.Duration {
	return value.Round(time.Millisecond)
}

// TextToHTML converts newlines in text to HTML <br> tags.
func TextToHTML(value string) string {
	return newlineMatcher.ReplaceAllLiteralString(value, "<br>")
}

// Timestamp returns the current time in RFC1123Z format.
func Timestamp() string {
	return timestamp(time.Now())
}
