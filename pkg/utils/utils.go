// Copyright (C) 2025 Petr Malik
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at <https://mozilla.org/MPL/2.0/>.

// Package utils provides general-purpose utilities for JSON handling and panic recovery.
package utils

import (
	"cmp"
	"encoding/json"
	"errors"
	"fmt"
	"maps"
	"regexp"
	"slices"

	"github.com/kaptinlin/jsonrepair"
	"github.com/santhosh-tekuri/jsonschema/v6"
	"golang.org/x/exp/constraints"
)

var (
	// ErrRecoveredPanic is returned when a panic is recovered and converted to an error.
	ErrRecoveredPanic = errors.New("recovered panic")

	// ErrCouldNotRepairJSON is returned when malformed JSON cannot be automatically fixed.
	ErrCouldNotRepairJSON = errors.New("malformed JSON could not be repaired")

	// ErrInvalidJSONSchema is returned when the provided JSON schema is invalid.
	ErrInvalidJSONSchema = errors.New("schema structure or keywords do not conform to the JSON Schema standard")

	// ErrJSONSchemaValidation is returned when JSON schema validation fails.
	ErrJSONSchemaValidation = errors.New("data format does not meet the defined schema requirements")

	jsonMarkdownMatcher = regexp.MustCompile("(?s)```json\\s*(\\{.*?\\})\\s*```")

	newlineMatcher = regexp.MustCompile(`\r?\n`)
)

// ConvertIntPtr converts a pointer of any integer type to a pointer of another integer type.
// If the input pointer is nil, returns nil. Otherwise, returns a pointer to the converted value.
//
// Warning: Conversions between different integer types may result in data loss or overflow.
// The conversion follows Go's standard truncation behavior (e.g., uint64(2^32) -> int32(0)).
func ConvertIntPtr[From constraints.Integer, To constraints.Integer](ptr *From) *To {
	if ptr != nil {
		converted := To(*ptr)
		return &converted
	}
	return nil
}

// NoPanic executes the provided function and recovers from any panic by converting it to error if that occurs.
func NoPanic(fn func() error) (err error) {
	defer func() {
		if p := recover(); p != nil {
			err = fmt.Errorf("%w: %v", ErrRecoveredPanic, p)
		}
	}()
	return fn()
}

// RepairTextJSON attempts to repair common issues with plain-text JSON generated by LLMs.
// If the input is already valid JSON, it is returned as-is.
func RepairTextJSON(content string) (string, error) {
	if json.Valid([]byte(content)) {
		return content, nil
	}
	repaired, err := jsonrepair.JSONRepair(JSONFromMarkdown(content))
	if err != nil {
		return content, fmt.Errorf("%w: %v", ErrCouldNotRepairJSON, err)
	}

	return repaired, nil
}

// JSONFromMarkdown extracts JSON content from a given Markdown string.
// If a JSON block is found, it returns the JSON content as a string.
// If no JSON block is found, it returns the original content.
func JSONFromMarkdown(content string) string {
	if found := jsonMarkdownMatcher.FindStringSubmatch(content); len(found) > 0 {
		return found[1]
	}
	return content
}

// ToLines converts a value to []string for display.
// For string values, splits them into lines.
// For objects, converts to pretty-printed JSON and splits into lines.
func ToLines(value interface{}) []string {
	return SplitLines(ToString(value))
}

// SplitLines splits text by newlines supporting both \n and \r\n and preserves empty lines.
// Returns an empty slice for empty input.
func SplitLines(text string) []string {
	if text == "" {
		return []string{}
	}
	return newlineMatcher.Split(text, -1)
}

// ToString converts a value to a string for display purposes.
// For string values, returns as-is.
// For objects, converts to pretty-printed JSON with indentation.
func ToString(value interface{}) string {
	if str, ok := value.(string); ok {
		return str
	}
	jsonBytes, err := json.MarshalIndent(value, "", "  ")
	if err != nil {
		return fmt.Sprintf("%v", value)
	}
	return string(jsonBytes)
}

// ValidateAgainstSchema validates that one or more values conform to the given JSON schema.
// The schema is compiled and validated exactly once.
func ValidateAgainstSchema(schema map[string]interface{}, values ...interface{}) error {
	// Always compile and validate the schema, even if no values are provided.
	compiler := jsonschema.NewCompiler()
	compiler.DefaultDraft(jsonschema.Draft2020)
	if err := compiler.AddResource("schema.json", schema); err != nil {
		return fmt.Errorf("schema validation failed: %w: %v", ErrInvalidJSONSchema, err)
	}
	compiledSchema, err := compiler.Compile("schema.json")
	if err != nil {
		return fmt.Errorf("schema compilation failed: %w: %v", ErrInvalidJSONSchema, err)
	}

	// Validate each value against the schema.
	for i, value := range values {
		if err := compiledSchema.Validate(value); err != nil {
			return fmt.Errorf("item %d does not conform to schema: %w: %v", i+1, ErrJSONSchemaValidation, err)
		}
	}

	return nil
}

// SortedKeys returns a sorted slice of unique keys from one or more maps.
// When multiple maps are provided, it collects all unique keys and returns them sorted.
// If no keys are found, returns an empty slice.
func SortedKeys[K cmp.Ordered, V any](m ...map[K]V) []K {
	// Collect unique keys using a map for deduplication.
	keySet := make(map[K]struct{})
	for _, mapItem := range m {
		for key := range mapItem {
			keySet[key] = struct{}{}
		}
	}

	// Return sorted keys, or empty slice if no keys found.
	if sorted := slices.Sorted(maps.Keys(keySet)); sorted != nil {
		return sorted
	}
	return []K{}
}
